<h3> Алгоритм работы. </h3>

1. Указать нужную схему в конфиг файле. 
2. Там же установить hbm2ddl (как эту хрень сокращенно называют?) в creat-drop режим
   <br> Необходимо, чтобы потом, не создавались одинаковые записи и потом, после добавления автомобилей и получения по авто - компилятор не говорил, что есть несколько запрашиваемых элементов.
3. Создать класс Car, реализовать его в модели, связать с User (Машина должна принадлежать человеку, не наоборот)
4. Модель -> ДАО -> Сервис. 
5. Добавить в конфиг класс - класс Car
6. Оверрайднуть ТуСтринг у обоих классов (для корректного вывода, потом, в мейн-классе) и добавить в User доп конструктор
7. Делать грязь в мейне

--- 
### Вопросы
1. В UserDaoImpl идет внедрение SessionFabric через Spring. А че, так можно что ли было? Поэтому он не требует каждый раз создавать сессию? Обязательно покопайся в этом вопросе. Если нихуя не поймешь - спроси Семёна.
2. Нахуя было делать два интерфейса, если можно было ограничиться одним? Для "чистоты" кода, чтобы не смешивать разные пакеты? Типа один интерфейс - одна реализация? 
3. Я еще могу понять, почему мы не открываем сессию в методах (в ЮзерДао), но почему мы не коммитим? Если сейв - коммит автоматом? И почему нет транзакций, я же только их, сука, понял
---
### Дальнейшей изучение. 
1. @Transactional(readOnly = true). Что это за хуйня и с чем её едят. 
2. Отключение предупреждений об ошибках при помощи @SuppressWarnings("unchecked"). Если я правильно понимаю - именно эта штука 
3. @Repository
4. 
